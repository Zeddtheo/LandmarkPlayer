<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>3Dç‰™å¼“æ ‡è®°ç‚¹æŸ¥çœ‹å™¨ - æ¼”ç¤ºç‰ˆ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font:14px/1.4 'Microsoft YaHei','å¾®è½¯é›…é»‘',sans-serif}
    #toolbar{position:fixed;top:8px;right:8px;display:flex;flex-wrap:wrap;gap:8px;z-index:10;justify-content:flex-end}
    #viewer{position:absolute;inset:0}
    button{background:#1f2937;color:#eee;border:1px solid #334155;border-radius:6px;padding:6px 14px;cursor:pointer;font:600 14px/1 'Microsoft YaHei','å¾®è½¯é›…é»‘',sans-serif;transition:all 0.2s ease}
    button:hover{background:#374151;transform:translateY(-1px)}
    input[type=file]{display:none}
    label.btn{background:#1f2937;border:1px solid #334155;border-radius:6px;padding:6px 14px;cursor:pointer;font:600 14px/1 'Microsoft YaHei','å¾®è½¯é›…é»‘',sans-serif;transition:all 0.2s ease}
    label.btn:hover{background:#374151;transform:translateY(-1px)}
    #toolbar .control{background:#1f2937;border:1px solid #334155;border-radius:6px;padding:6px 12px;color:#eee;display:flex;align-items:center;gap:8px;font:600 14px/1 'Microsoft YaHei','å¾®è½¯é›…é»‘',sans-serif}
    #toolbar .control span{white-space:nowrap}
    input[type=range]{width:100px}
    input[type=color]{width:42px;height:28px;padding:0;border:none;border-radius:4px;cursor:pointer}
    #status{position:fixed;bottom:10px;left:10px;background:rgba(0,0,0,0.9);color:#60a5fa;padding:8px 12px;border-radius:4px;font-size:12px;z-index:10;backdrop-filter:blur(10px);border:1px solid #334155}
    #demo-info{position:fixed;top:8px;left:8px;background:rgba(0,0,0,0.9);padding:16px;border-radius:8px;max-width:280px;font-size:12px;line-height:1.4;z-index:10;backdrop-filter:blur(10px);border:1px solid #334155}
    #demo-info h3{margin:0 0 8px 0;color:#60a5fa;font-size:14px}
    #demo-info p{margin:4px 0;color:#d1d5db}
    #demo-info .close-btn{position:absolute;top:8px;right:8px;background:none;border:none;color:#9ca3af;cursor:pointer;font-size:16px;padding:0;width:20px;height:20px}
  </style>
  <link rel="icon" href="data:,">
</head>
<body>
  <!-- æ¼”ç¤ºè¯´æ˜ -->
  <div id="demo-info">
    <button class="close-btn" onclick="document.getElementById('demo-info').style.display='none'">Ã—</button>
    <h3>ğŸ¦· 3Dç‰™å¼“æ ‡è®°ç‚¹æŸ¥çœ‹å™¨</h3>
    <p><strong>æ¼”ç¤ºåŠŸèƒ½ï¼š</strong></p>
    <p>â€¢ è‡ªåŠ¨æ˜¾ç¤ºå†…ç½®3Dç‰™å¼“æ¨¡å‹</p>
    <p>â€¢ 14ä¸ªé¢„è®¾ç‰™é½¿æ ‡è®°ç‚¹</p>
    <p>â€¢ é¼ æ ‡å·¦é”®æ‹–æ‹½æ—‹è½¬è§†è§’</p>
    <p>â€¢ æ»šè½®ç¼©æ”¾ï¼Œå³é”®å¹³ç§»</p>
    <p>â€¢ ç‚¹å‡»çº¢è‰²æ ‡è®°ç‚¹å¯æ‹–æ‹½ç§»åŠ¨</p>
    <p><strong>æ–‡ä»¶åŠŸèƒ½ï¼š</strong></p>
    <p>â€¢ æ”¯æŒåŠ è½½è‡ªå®šä¹‰STLå’ŒJSONæ–‡ä»¶</p>
    <p>â€¢ å¯è°ƒæ•´æ ‡è®°ç‚¹å¤§å°å’Œé¢œè‰²</p>
    <p>â€¢ æ”¯æŒå¯¼å‡ºç¼–è¾‘åçš„æ ‡è®°ç‚¹æ•°æ®</p>
  </div>

  <div id="status">æ­£åœ¨åˆå§‹åŒ–3Dåœºæ™¯...</div>

  <div id="toolbar">
    <label class="btn">
      ğŸ“‚ åŠ è½½STL<input id="open-stl" type="file" accept=".stl">
    </label>
    <label class="btn">
      ğŸ“ åŠ è½½JSON<input id="open-json" type="file" accept=".json">
    </label>
    <button id="export-json">ğŸ’¾ å¯¼å‡ºJSON</button>
    <div class="control">
      <span>é¢œè‰²:</span>
      <input id="point-color" type="color" value="#ff4444">
    </div>
    <div class="control">
      <span>å¤§å°:</span>
      <input id="point-size" type="range" min="0.5" max="3" step="0.1" value="1">
      <span id="point-size-value">1.0</span>
    </div>
    <button id="reset-demo">ğŸ”„ é‡ç½®æ¼”ç¤º</button>
  </div>

  <div id="viewer"></div>

  <!-- ä½¿ç”¨ç¨³å®šçš„Three.jsç‰ˆæœ¬ -->
  <script src="https://unpkg.com/three@r155/build/three.min.js"></script>
  <script src="https://unpkg.com/three@r155/examples/js/controls/OrbitControls.js"></script>

  <!-- å†…è”STLåŠ è½½å™¨ -->
  <script>
    // ç®€åŒ–çš„STLåŠ è½½å™¨
    THREE.STLLoader = function() {};
    
    THREE.STLLoader.prototype = {
      parse: function(arrayBuffer) {
        function isBinary(data) {
          const reader = new DataView(data);
          const numTriangles = reader.getUint32(80, true);
          const expectedLength = 80 + 4 + numTriangles * (4 * 3 * 4 + 2);
          return expectedLength === data.byteLength;
        }
        
        function parseBinary(data) {
          const reader = new DataView(data);
          const numTriangles = reader.getUint32(80, true);
          
          const vertices = [];
          const normals = [];
          let offset = 84;
          
          for (let i = 0; i < numTriangles; i++) {
            // æ³•å‘é‡
            const nx = reader.getFloat32(offset, true);
            const ny = reader.getFloat32(offset + 4, true);
            const nz = reader.getFloat32(offset + 8, true);
            offset += 12;
            
            // ä¸‰ä¸ªé¡¶ç‚¹
            for (let j = 0; j < 3; j++) {
              const vx = reader.getFloat32(offset, true);
              const vy = reader.getFloat32(offset + 4, true);
              const vz = reader.getFloat32(offset + 8, true);
              offset += 12;
              
              vertices.push(vx, vy, vz);
              normals.push(nx, ny, nz);
            }
            
            offset += 2; // è·³è¿‡å±æ€§å­—èŠ‚
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
          
          return geometry;
        }
        
        function parseASCII(data) {
          const text = new TextDecoder().decode(data);
          const vertices = [];
          const normals = [];
          
          const lines = text.split('\n');
          let currentNormal = [0, 0, 0];
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            if (line.startsWith('facet normal')) {
              const parts = line.split(/\s+/);
              currentNormal = [
                parseFloat(parts[2]),
                parseFloat(parts[3]),
                parseFloat(parts[4])
              ];
            } else if (line.startsWith('vertex')) {
              const parts = line.split(/\s+/);
              vertices.push(
                parseFloat(parts[1]),
                parseFloat(parts[2]),
                parseFloat(parts[3])
              );
              normals.push(...currentNormal);
            }
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
          
          return geometry;
        }
        
        if (isBinary(arrayBuffer)) {
          return parseBinary(arrayBuffer);
        } else {
          return parseASCII(arrayBuffer);
        }
      }
    };
  </script>

  <script>
    // ç­‰å¾…é¡µé¢å’Œè„šæœ¬å®Œå…¨åŠ è½½
    window.addEventListener('load', function() {
      // æ£€æŸ¥Three.jsæ˜¯å¦åŠ è½½æˆåŠŸ
      if (typeof THREE === 'undefined') {
        document.getElementById('status').innerHTML = 'âŒ éœ€è¦ç½‘ç»œè¿æ¥åŠ è½½3Då¼•æ“ï¼Œè¯·ç¡®ä¿ç½‘ç»œè¿æ¥æ­£å¸¸';
        document.getElementById('viewer').innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#999;font-size:18px;">éœ€è¦ç½‘ç»œè¿æ¥æ‰èƒ½è¿è¡Œ</div>';
        return;
      }
      
      // æ£€æŸ¥OrbitControlsæ˜¯å¦åŠ è½½
      if (typeof THREE.OrbitControls === 'undefined') {
        document.getElementById('status').innerHTML = 'âš ï¸ æ§åˆ¶å™¨åŠ è½½å¤±è´¥ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™';
      }
      
      // å¼€å§‹åˆå§‹åŒ–åº”ç”¨
      initApp();
    });

    function initApp() {
      // å…¨å±€å˜é‡
      let scene, camera, renderer, controls;
      let stlMesh = null;
      let landmarkMeshes = [];
      let landmarkLabels = [];
      let landmarks = [];
      const state = { 
        pointSizeMultiplier: 1, 
        pointColor: '#ff4444' 
      };

      const pointer = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      const dragState = { mesh: null, label: null, landmark: null };
      const statusEl = document.getElementById('status');

      function updateStatus(message) {
        console.log(message);
        statusEl.textContent = message;
      }

      // ç”Ÿæˆå†…ç½®çš„ç‰™å¼“å½¢çŠ¶STLæ•°æ®
      function generateDemoSTLGeometry() {
        const vertices = [];
        const normals = [];
        
        // ç”Ÿæˆä¸€ä¸ªUå½¢ç‰™å¼“
        const segments = 40;
        const radiusOuter = 30;
        const radiusInner = 22;
        const height = 8;
        
        for (let i = 0; i < segments; i++) {
          const angle1 = (Math.PI * i) / segments;
          const angle2 = (Math.PI * (i + 1)) / segments;
          
          const x1o = Math.cos(angle1) * radiusOuter;
          const z1o = Math.sin(angle1) * radiusOuter;
          const x1i = Math.cos(angle1) * radiusInner;
          const z1i = Math.sin(angle1) * radiusInner;
          
          const x2o = Math.cos(angle2) * radiusOuter;
          const z2o = Math.sin(angle2) * radiusOuter;
          const x2i = Math.cos(angle2) * radiusInner;
          const z2i = Math.sin(angle2) * radiusInner;
          
          // é¡¶é¢
          vertices.push(x1o, height, z1o, x1i, height, z1i, x2o, height, z2o);
          normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
          
          vertices.push(x1i, height, z1i, x2i, height, z2i, x2o, height, z2o);
          normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
          
          // åº•é¢
          vertices.push(x1o, 0, z1o, x2o, 0, z2o, x1i, 0, z1i);
          normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0);
          
          vertices.push(x1i, 0, z1i, x2o, 0, z2o, x2i, 0, z2i);
          normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0);
          
          // å¤–ä¾§é¢
          vertices.push(x1o, 0, z1o, x1o, height, z1o, x2o, height, z2o);
          vertices.push(x1o, 0, z1o, x2o, height, z2o, x2o, 0, z2o);
          for (let j = 0; j < 6; j++) {
            normals.push(Math.cos(angle1 + Math.PI/2), 0, Math.sin(angle1 + Math.PI/2));
          }
          
          // å†…ä¾§é¢
          vertices.push(x1i, 0, z1i, x2i, height, z2i, x1i, height, z1i);
          vertices.push(x1i, 0, z1i, x2i, 0, z2i, x2i, height, z2i);
          for (let j = 0; j < 6; j++) {
            normals.push(-Math.cos(angle1 + Math.PI/2), 0, -Math.sin(angle1 + Math.PI/2));
          }
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        
        return geometry;
      }

      // ç”Ÿæˆå†…ç½®çš„landmarkæ•°æ®
      function generateDemoLandmarks() {
        return [
          { id: "UR7", name: "å³ä¸Šç¬¬äºŒç£¨ç‰™", position: new THREE.Vector3(-24, 4, 6) },
          { id: "UR6", name: "å³ä¸Šç¬¬ä¸€ç£¨ç‰™", position: new THREE.Vector3(-18, 4, 10) },
          { id: "UR5", name: "å³ä¸Šç¬¬äºŒå‰ç£¨ç‰™", position: new THREE.Vector3(-14, 4, 14) },
          { id: "UR4", name: "å³ä¸Šç¬¬ä¸€å‰ç£¨ç‰™", position: new THREE.Vector3(-10, 4, 18) },
          { id: "UR3", name: "å³ä¸Šå°–ç‰™", position: new THREE.Vector3(-7, 4, 21) },
          { id: "UR2", name: "å³ä¸Šä¾§åˆ‡ç‰™", position: new THREE.Vector3(-4, 4, 24) },
          { id: "UR1", name: "å³ä¸Šä¸­åˆ‡ç‰™", position: new THREE.Vector3(-1.5, 4, 26) },
          { id: "UL1", name: "å·¦ä¸Šä¸­åˆ‡ç‰™", position: new THREE.Vector3(1.5, 4, 26) },
          { id: "UL2", name: "å·¦ä¸Šä¾§åˆ‡ç‰™", position: new THREE.Vector3(4, 4, 24) },
          { id: "UL3", name: "å·¦ä¸Šå°–ç‰™", position: new THREE.Vector3(7, 4, 21) },
          { id: "UL4", name: "å·¦ä¸Šç¬¬ä¸€å‰ç£¨ç‰™", position: new THREE.Vector3(10, 4, 18) },
          { id: "UL5", name: "å·¦ä¸Šç¬¬äºŒå‰ç£¨ç‰™", position: new THREE.Vector3(14, 4, 14) },
          { id: "UL6", name: "å·¦ä¸Šç¬¬ä¸€ç£¨ç‰™", position: new THREE.Vector3(18, 4, 10) },
          { id: "UL7", name: "å·¦ä¸Šç¬¬äºŒç£¨ç‰™", position: new THREE.Vector3(24, 4, 6) }
        ];
      }

      // åˆå§‹åŒ–3Dåœºæ™¯
      function init() {
        try {
          updateStatus('æ­£åœ¨åˆ›å»º3Dåœºæ™¯...');
          
          const viewer = document.getElementById('viewer');
          
          // åœºæ™¯
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x1a1a1a);
          
          // ç›¸æœº
          const w = viewer.clientWidth || window.innerWidth;
          const h = viewer.clientHeight || window.innerHeight;
          camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
          camera.position.set(0, 40, 80);
          
          // æ¸²æŸ“å™¨
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(w, h);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          viewer.appendChild(renderer.domElement);
          
          // æ§åˆ¶å™¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
          if (typeof THREE.OrbitControls !== 'undefined') {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.target.set(0, 4, 15);
          }
          
          // ç¯å…‰
          scene.add(new THREE.AmbientLight(0x404040, 0.6));
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(50, 50, 30);
          directionalLight.castShadow = true;
          scene.add(directionalLight);
          
          // æ·»åŠ ä¸€äº›é¢å¤–çš„å…‰æº
          const light1 = new THREE.PointLight(0xffffff, 0.3, 100);
          light1.position.set(-30, 20, 30);
          scene.add(light1);
          
          const light2 = new THREE.PointLight(0xffffff, 0.3, 100);
          light2.position.set(30, 20, 30);
          scene.add(light2);
          
          // åæ ‡è½´
          const axes = new THREE.AxesHelper(20);
          axes.material.transparent = true;
          axes.material.opacity = 0.3;
          scene.add(axes);
          
          // çª—å£è°ƒæ•´
          window.addEventListener('resize', onResize);
          
          // äº¤äº’å¤„ç†
          if (controls) {
            setupInteractionHandlers();
          }
          
          // å¼€å§‹åŠ¨ç”»å¾ªç¯
          animate();
          
          updateStatus('æ­£åœ¨åŠ è½½æ¼”ç¤ºæ•°æ®...');
          
          // åŠ è½½æ¼”ç¤ºæ•°æ®
          loadDemoData();
          
        } catch (error) {
          updateStatus('åˆå§‹åŒ–å¤±è´¥: ' + error.message);
          console.error('åˆå§‹åŒ–é”™è¯¯:', error);
        }
      }

      function loadDemoData() {
        try {
          // åˆ›å»ºæ¼”ç¤ºSTLæ¨¡å‹
          const geometry = generateDemoSTLGeometry();
          const material = new THREE.MeshLambertMaterial({ 
            color: 0xcccccc,
            side: THREE.DoubleSide
          });
          
          stlMesh = new THREE.Mesh(geometry, material);
          stlMesh.castShadow = true;
          stlMesh.receiveShadow = true;
          scene.add(stlMesh);
          
          // åˆ›å»ºæ¼”ç¤ºlandmarks
          landmarks = generateDemoLandmarks();
          renderLandmarks();
          
          updateStatus('æ¼”ç¤ºæ•°æ®åŠ è½½å®Œæˆï¼ä½ å¯ä»¥æ‹–æ‹½çº¢è‰²æ ‡è®°ç‚¹ç¼–è¾‘ä½ç½®');
          
        } catch (error) {
          updateStatus('æ¼”ç¤ºæ•°æ®åŠ è½½å¤±è´¥: ' + error.message);
          console.error('æ¼”ç¤ºæ•°æ®åŠ è½½é”™è¯¯:', error);
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      function onResize() {
        const viewer = document.getElementById('viewer');
        const w = viewer.clientWidth || window.innerWidth;
        const h = viewer.clientHeight || window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }

      function renderLandmarks() {
        // æ¸…é™¤ç°æœ‰landmarks
        landmarkMeshes.forEach(mesh => scene.remove(mesh));
        landmarkLabels.forEach(label => scene.remove(label));
        landmarkMeshes = [];
        landmarkLabels = [];
        
        if (!landmarks.length) return;
        
        const sphereRadius = 1.5 * state.pointSizeMultiplier;
        
        landmarks.forEach(landmark => {
          // åˆ›å»ºçƒä½“
          const geometry = new THREE.SphereGeometry(sphereRadius, 12, 8);
          const material = new THREE.MeshLambertMaterial({ 
            color: state.pointColor,
            transparent: true,
            opacity: 0.9
          });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.copy(landmark.position);
          sphere.userData = { landmarkId: landmark.id, landmark };
          sphere.castShadow = true;
          scene.add(sphere);
          landmarkMeshes.push(sphere);
          
          // åˆ›å»ºæ–‡å­—æ ‡ç­¾
          const label = createLabelSprite(landmark.id);
          label.position.copy(landmark.position);
          label.position.y += sphereRadius + 2;
          label.userData = { landmarkId: landmark.id, landmark };
          scene.add(label);
          landmarkLabels.push(label);
        });
      }

      function createLabelSprite(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        
        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#ffffff';
        context.font = '24px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, canvas.width/2, canvas.height/2);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true,
          alphaTest: 0.1
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(8, 4, 1);
        sprite.renderOrder = 10;
        
        return sprite;
      }

      // äº¤äº’å¤„ç†
      function setupInteractionHandlers() {
        const canvas = renderer.domElement;
        canvas.addEventListener('pointerdown', onPointerDown);
        canvas.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }

      function onPointerDown(event) {
        if (event.button !== 0) return;
        
        updatePointer(event);
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(landmarkMeshes);
        
        if (intersects.length > 0) {
          const mesh = intersects[0].object;
          const landmarkId = mesh.userData.landmarkId;
          
          dragState.mesh = mesh;
          dragState.label = landmarkLabels.find(l => l.userData.landmarkId === landmarkId);
          dragState.landmark = landmarks.find(l => l.id === landmarkId);
          
          if (controls) controls.enabled = false;
          event.preventDefault();
          updateStatus('æ‹–æ‹½ä¸­... æ¾å¼€é¼ æ ‡å®Œæˆç¼–è¾‘');
        }
      }

      function onPointerMove(event) {
        if (!dragState.mesh || !stlMesh) return;
        
        updatePointer(event);
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObject(stlMesh);
        
        if (intersects.length > 0) {
          const newPos = intersects[0].point;
          dragState.mesh.position.copy(newPos);
          if (dragState.label) {
            dragState.label.position.copy(newPos);
            dragState.label.position.y += 3;
          }
          if (dragState.landmark) {
            dragState.landmark.position.copy(newPos);
          }
        }
        event.preventDefault();
      }

      function onPointerUp() {
        if (dragState.mesh) {
          dragState.mesh = null;
          dragState.label = null;
          dragState.landmark = null;
          if (controls) controls.enabled = true;
          updateStatus('ç¼–è¾‘å®Œæˆï¼ä½ å¯ä»¥ç»§ç»­ç¼–è¾‘å…¶ä»–æ ‡è®°ç‚¹');
        }
      }

      function updatePointer(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      // æ–‡ä»¶å¤„ç†
      async function handleSTLFile(file) {
        try {
          updateStatus('æ­£åœ¨åŠ è½½STLæ–‡ä»¶...');
          
          const arrayBuffer = await file.arrayBuffer();
          const loader = new THREE.STLLoader();
          const geometry = loader.parse(arrayBuffer);
          geometry.computeVertexNormals();
          
          const material = new THREE.MeshLambertMaterial({ 
            color: 0xcccccc,
            side: THREE.DoubleSide
          });
          
          if (stlMesh) {
            scene.remove(stlMesh);
          }
          
          stlMesh = new THREE.Mesh(geometry, material);
          stlMesh.castShadow = true;
          stlMesh.receiveShadow = true;
          scene.add(stlMesh);
          
          // è°ƒæ•´ç›¸æœºè§†è§’
          const box = new THREE.Box3().setFromObject(stlMesh);
          const size = box.getSize(new THREE.Vector3()).length();
          const center = box.getCenter(new THREE.Vector3());
          
          if (controls) {
            controls.target.copy(center);
          }
          camera.position.copy(center.clone().add(new THREE.Vector3(size * 0.5, size * 0.5, size * 1.2)));
          
          updateStatus('STLæ–‡ä»¶åŠ è½½æˆåŠŸï¼');
          
          // é‡æ–°æ¸²æŸ“landmarks
          if (landmarks.length) {
            renderLandmarks();
          }
          
        } catch (error) {
          updateStatus('STLæ–‡ä»¶åŠ è½½å¤±è´¥: ' + error.message);
          console.error('STLåŠ è½½é”™è¯¯:', error);
        }
      }

      async function handleJSONFile(file) {
        try {
          updateStatus('æ­£åœ¨åŠ è½½JSONæ–‡ä»¶...');
          
          const text = await file.text();
          const json = JSON.parse(text);
          
          let landmarkData = [];
          
          if (json.landmarks && Array.isArray(json.landmarks)) {
            landmarkData = json.landmarks;
          } else if (json.markups && Array.isArray(json.markups) && json.markups.length > 0) {
            const markup = json.markups[0];
            if (markup.controlPoints && Array.isArray(markup.controlPoints)) {
              landmarkData = markup.controlPoints.map(cp => ({
                id: cp.id || cp.label,
                name: cp.label || cp.id,
                position: cp.position
              }));
            }
          }
          
          landmarks = landmarkData.filter(lm => 
            lm.position && Array.isArray(lm.position) && lm.position.length === 3
          ).map(lm => ({
            id: lm.id || lm.name || 'landmark',
            name: lm.name || lm.id || 'landmark',
            position: new THREE.Vector3(lm.position[0], lm.position[1], lm.position[2])
          }));
          
          renderLandmarks();
          updateStatus(`JSONæ–‡ä»¶åŠ è½½æˆåŠŸï¼Œè½½å…¥${landmarks.length}ä¸ªæ ‡è®°ç‚¹ï¼`);
          
        } catch (error) {
          updateStatus('JSONæ–‡ä»¶åŠ è½½å¤±è´¥: ' + error.message);
          console.error('JSONåŠ è½½é”™è¯¯:', error);
        }
      }

      // UIäº‹ä»¶ç»‘å®š
      function bindUI() {
        // æ–‡ä»¶è¾“å…¥
        document.getElementById('open-stl').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) handleSTLFile(file);
        });

        document.getElementById('open-json').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) handleJSONFile(file);
        });

        // é¢œè‰²æ§åˆ¶
        document.getElementById('point-color').addEventListener('input', (e) => {
          state.pointColor = e.target.value;
          landmarkMeshes.forEach(mesh => {
            mesh.material.color.setStyle(state.pointColor);
          });
        });

        // å¤§å°æ§åˆ¶
        const sizeRange = document.getElementById('point-size');
        const sizeValue = document.getElementById('point-size-value');
        sizeRange.addEventListener('input', (e) => {
          state.pointSizeMultiplier = parseFloat(e.target.value);
          sizeValue.textContent = state.pointSizeMultiplier.toFixed(1);
          renderLandmarks();
        });

        // å¯¼å‡ºJSON
        document.getElementById('export-json').addEventListener('click', () => {
          if (!landmarks.length) {
            updateStatus('æ²¡æœ‰æ ‡è®°ç‚¹å¯ä»¥å¯¼å‡º');
            return;
          }
          
          const exportData = {
            coord_space: 'model',
            units: 'mm',
            landmarks: landmarks.map(lm => ({
              id: lm.id,
              name: lm.name,
              position: [lm.position.x, lm.position.y, lm.position.z]
            }))
          };
          
          const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'landmarks-edited.json';
          a.click();
          URL.revokeObjectURL(url);
          
          updateStatus('æ ‡è®°ç‚¹æ•°æ®å·²å¯¼å‡º');
        });

        // é‡ç½®æ¼”ç¤º
        document.getElementById('reset-demo').addEventListener('click', () => {
          if (stlMesh) scene.remove(stlMesh);
          landmarkMeshes.forEach(mesh => scene.remove(mesh));
          landmarkLabels.forEach(label => scene.remove(label));
          
          landmarkMeshes = [];
          landmarkLabels = [];
          
          loadDemoData();
        });
      }

      // å¯åŠ¨åº”ç”¨
      init();
      bindUI();
    }
  </script>
</body>
</html>